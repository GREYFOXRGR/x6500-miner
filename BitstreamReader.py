# Parse a .BIT file generated by Xilinx's bitgen.
# That is the default file generated during ISE's compilation.
#
#
# FILE FORMAT
#
# Consists of an initial 11 bytes of unknown content (???)
# Then 5 fields of the format:
#	1 byte key
#	2 byte, Big Endian Length (EXCEPT: The last field, which has a 4 byte length)
#	data (of length specified above ^)
# 
# The 5 fields have keys in the sequence a, b, c, d, e
# The data from the first 4 fields are strings:
# design name, part name, date, time
# The last field is the raw bitstream.
#

# Dictionary for looking up idcodes from device names:
idcode_lut = {'6slx150fgg484': 0x401d093, '6slx45csg324': 0x4008093}

class BitFileReadError(Exception):
	_corruptFileMessage = "Unable to parse .bit file; header is malformed. Is it really a Xilinx .bit file?"

	def __init__(self, value=None):
		self.parameter = BitFileReadError._corruptFileMessage if value is None else value
	def __str__(self):
		return repr(self.parameter)

class BitFile:
	# Read a .bit file and return a BitFile object.
	@staticmethod
	def read(filestream):
		bitfile = BitFile()

		# 11 bytes of unknown data
		if BitFile._readLength(filestream) != 9:
			raise BitFileReadError()

		BitFile._readOrDie(filestream, 11)

		bitfile.designname = BitFile._readField(filestream, 'a').rstrip('\0')
		bitfile.part = BitFile._readField(filestream, 'b').rstrip('\0')
		bitfile.date = BitFile._readField(filestream, 'c').rstrip('\0')
		bitfile.time = BitFile._readField(filestream, 'd').rstrip('\0')
		bitfile.idcode = idcode_lut[bitfile.part]

		if BitFile._readOrDie(filestream, 1) != 'e':
			raise BitFileReadError()

		length = BitFile._readLength4(filestream)
		bitfile.bitstream = BitFile._readOrDie(filestream, length)

		return bitfile
	
	# Read a 2-byte, unsigned, Big Endian length.
	@staticmethod
	def _readLength(filestream):
		length = BitFile._readOrDie(filestream, 2)

		return (ord(length[0]) << 8) | ord(length[1])

	@staticmethod
	def _readLength4(filestream):
		length = BitFile._readOrDie(filestream, 4)

		return (ord(length[0]) << 24) | (ord(length[1]) << 16) | (ord(length[2]) << 8) | ord(length[3])

	# Read length bytes, or throw an exception
	@staticmethod
	def _readOrDie(filestream, length):
		data = filestream.read(length)

		if len(data) < length:
			raise BitFileReadError()

		return data

	@staticmethod
	def _readField(filestream, key):
		if BitFile._readOrDie(filestream, 1) != key:
			raise BitFileReadError()

		length = BitFile._readLength(filestream)
		data = BitFile._readOrDie(filestream, length)

		return data
		

	def __init__(self):
		self.designname = None
		self.part = None
		self.date = None
		self.time = None
		self.length = None
		self.bitstream = None

